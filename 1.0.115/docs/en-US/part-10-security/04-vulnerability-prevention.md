# Part 10.4: Vulnerability Prevention

## Introduction

Vulnerability prevention in Claude Code encompasses proactive security measures to prevent common attack vectors, including injection attacks, path traversal, privilege escalation, and denial of service. This chapter explores the comprehensive defensive mechanisms that protect against security vulnerabilities throughout the system.

## Table of Contents
1. [Input Validation Framework](#input-validation-framework)
2. [Injection Attack Prevention](#injection-attack-prevention)
3. [Path Security](#path-security)
4. [Command Execution Safety](#command-execution-safety)
5. [Rate Limiting and DoS Prevention](#rate-limiting-and-dos-prevention)
6. [Security Monitoring](#security-monitoring)
7. [Vulnerability Scanning](#vulnerability-scanning)
8. [Performance Implications](#performance-implications)

## Input Validation Framework

### Comprehensive Input Validator

```javascript
class InputValidationFramework {
  constructor() {
    this.validators = new Map();
    this.schemas = new Map();
    this.blacklists = new Map();
    this.whitelists = new Map();

    this.initializeValidators();
  }

  initializeValidators() {
    // Command input validator
    this.registerValidator('command', {
      type: 'string',
      maxLength: 1024,
      pattern: /^[a-zA-Z0-9\s\-_.\/]+$/,

      validate(input) {
        // Length check
        if (input.length > this.maxLength) {
          return {
            valid: false,
            error: `Command exceeds maximum length of ${this.maxLength}`
          };
        }

        // Character validation
        if (!this.pattern.test(input)) {
          return {
            valid: false,
            error: 'Command contains invalid characters'
          };
        }

        // Blacklist check
        const blacklisted = this.checkBlacklist(input);
        if (blacklisted) {
          return {
            valid: false,
            error: `Blacklisted command: ${blacklisted}`
          };
        }

        return { valid: true };
      },

      checkBlacklist(input) {
        const blacklist = [
          'rm -rf /',
          'format c:',
          ':(){ :|:& };:',  // Fork bomb
          'dd if=/dev/zero',
          'mkfs',
          'fdisk'
        ];

        for (const dangerous of blacklist) {
          if (input.includes(dangerous)) {
            return dangerous;
          }
        }

        return null;
      },

      sanitize(input) {
        // Remove dangerous patterns
        let sanitized = input;

        // Remove backticks
        sanitized = sanitized.replace(/`/g, '');

        // Remove command substitution
        sanitized = sanitized.replace(/\$\([^)]*\)/g, '');
        sanitized = sanitized.replace(/\${[^}]*}/g, '');

        // Remove redirections
        sanitized = sanitized.replace(/[<>]/g, '');

        // Remove pipe chains
        sanitized = sanitized.replace(/\|{2,}/g, '|');

        return sanitized;
      }
    });

    // File path validator
    this.registerValidator('filepath', {
      type: 'string',
      maxLength: 4096,

      validate(input) {
        const path = require('path');

        // Length check
        if (input.length > this.maxLength) {
          return {
            valid: false,
            error: 'Path exceeds maximum length'
          };
        }

        // Null byte check
        if (input.includes('\0')) {
          return {
            valid: false,
            error: 'Path contains null bytes'
          };
        }

        // Path traversal check
        if (this.hasPathTraversal(input)) {
          return {
            valid: false,
            error: 'Path traversal detected'
          };
        }

        // Normalize and validate
        const normalized = path.normalize(input);
        const resolved = path.resolve(normalized);

        // Check if path is within allowed directories
        if (!this.isAllowedPath(resolved)) {
          return {
            valid: false,
            error: 'Path is outside allowed directories'
          };
        }

        return { valid: true };
      },

      hasPathTraversal(input) {
        const patterns = [
          /\.\./,           // Parent directory
          /\.\.%2[fF]/,     // URL encoded
          /\.\.[\/\\]/,     // With separator
          /^~/              // Home directory
        ];

        return patterns.some(p => p.test(input));
      },

      isAllowedPath(resolvedPath) {
        const allowedPaths = [
          process.cwd(),
          '/tmp',
          '/var/tmp'
        ];

        return allowedPaths.some(allowed =>
          resolvedPath.startsWith(allowed)
        );
      },

      sanitize(input) {
        const path = require('path');

        // Remove traversal sequences
        let sanitized = input.replace(/\.\./g, '');

        // Remove null bytes
        sanitized = sanitized.replace(/\0/g, '');

        // Normalize path
        sanitized = path.normalize(sanitized);

        return sanitized;
      }
    });

    // URL validator
    this.registerValidator('url', {
      type: 'string',
      protocols: ['http', 'https'],

      validate(input) {
        try {
          const url = new URL(input);

          // Protocol check
          if (!this.protocols.includes(url.protocol.slice(0, -1))) {
            return {
              valid: false,
              error: `Invalid protocol: ${url.protocol}`
            };
          }

          // SSRF prevention
          if (this.isLocalURL(url)) {
            return {
              valid: false,
              error: 'Local URLs are not allowed'
            };
          }

          // Port restrictions
          const blockedPorts = [22, 23, 25, 445, 3389];
          if (blockedPorts.includes(parseInt(url.port))) {
            return {
              valid: false,
              error: `Blocked port: ${url.port}`
            };
          }

          return { valid: true };

        } catch (error) {
          return {
            valid: false,
            error: 'Invalid URL format'
          };
        }
      },

      isLocalURL(url) {
        const localPatterns = [
          /^localhost$/i,
          /^127\./,
          /^10\./,
          /^172\.(1[6-9]|2[0-9]|3[01])\./,
          /^192\.168\./,
          /^169\.254\./,  // Link-local
          /^::1$/,         // IPv6 localhost
          /^fc00:/,        // IPv6 private
          /^fe80:/         // IPv6 link-local
        ];

        return localPatterns.some(p => p.test(url.hostname));
      },

      sanitize(input) {
        try {
          const url = new URL(input);

          // Remove credentials
          url.username = '';
          url.password = '';

          // Remove fragments in certain contexts
          url.hash = '';

          return url.toString();

        } catch {
          return '';
        }
      }
    });

    // Content validator
    this.registerValidator('content', {
      type: 'string',
      maxLength: 1048576, // 1MB

      validate(input) {
        // Size check
        if (input.length > this.maxLength) {
          return {
            valid: false,
            error: 'Content exceeds maximum size'
          };
        }

        // Binary content check
        if (this.hasBinaryContent(input)) {
          return {
            valid: false,
            error: 'Binary content not allowed'
          };
        }

        // Script injection check
        if (this.hasScriptInjection(input)) {
          return {
            valid: false,
            error: 'Script injection detected'
          };
        }

        return { valid: true };
      },

      hasBinaryContent(input) {
        // Check for non-printable characters
        return /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/.test(input);
      },

      hasScriptInjection(input) {
        const patterns = [
          /<script[^>]*>/i,
          /<iframe[^>]*>/i,
          /javascript:/i,
          /on\w+\s*=/i,  // Event handlers
          /<embed[^>]*>/i,
          /<object[^>]*>/i
        ];

        return patterns.some(p => p.test(input));
      },

      sanitize(input) {
        // Remove scripts
        let sanitized = input.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');

        // Remove event handlers
        sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');

        // Escape HTML entities
        sanitized = sanitized
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#x27;');

        return sanitized;
      }
    });
  }

  registerValidator(name, validator) {
    this.validators.set(name, validator);
  }

  async validate(input, type, options = {}) {
    const validator = this.validators.get(type);

    if (!validator) {
      throw new Error(`Unknown validator type: ${type}`);
    }

    // Run validation
    const result = validator.validate.call(validator, input);

    if (!result.valid) {
      // Log validation failure
      await this.logValidationFailure(type, input, result.error);

      if (options.throwOnError) {
        throw new ValidationError(result.error);
      }
    }

    // Sanitize if valid and requested
    if (result.valid && options.sanitize) {
      result.sanitized = validator.sanitize.call(validator, input);
    }

    return result;
  }

  async logValidationFailure(type, input, error) {
    // Would log to security monitoring
    console.warn('Validation failure:', {
      type,
      error,
      timestamp: Date.now()
    });
  }
}

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

## Injection Attack Prevention

### SQL Injection Prevention

```javascript
class SQLInjectionPrevention {
  constructor() {
    this.patterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|CREATE|ALTER)\b)/gi,
      /(\b(OR|AND)\b\s*\d+\s*=\s*\d+)/gi,  // OR 1=1
      /(--|\#|\/\*|\*\/)/g,  // Comments
      /(\bEXEC(UTE)?\b|\bSP_\w+)/gi,  // Stored procedures
      /(\bXP_\w+)/gi,  // Extended procedures
      /(;|\||&&)/g  // Command separators
    ];
  }

  detect(input) {
    const detections = [];

    for (const pattern of this.patterns) {
      const matches = input.match(pattern);
      if (matches) {
        detections.push({
          pattern: pattern.toString(),
          matches
        });
      }
    }

    return detections.length > 0 ? detections : null;
  }

  prevent(query, params = []) {
    // Use parameterized queries
    return {
      text: query,
      values: params.map(p => this.escapeValue(p))
    };
  }

  escapeValue(value) {
    if (value === null || value === undefined) {
      return null;
    }

    if (typeof value === 'string') {
      // Escape single quotes
      return value.replace(/'/g, "''");
    }

    if (typeof value === 'number') {
      // Validate number
      if (!isFinite(value)) {
        throw new Error('Invalid number value');
      }
      return value;
    }

    if (value instanceof Date) {
      return value.toISOString();
    }

    // Don't allow other types
    throw new Error(`Unsupported value type: ${typeof value}`);
  }

  buildSafeQuery(template, params) {
    // Replace placeholders with escaped values
    let query = template;
    let paramIndex = 0;

    query = query.replace(/\?/g, () => {
      if (paramIndex >= params.length) {
        throw new Error('Insufficient parameters');
      }

      const value = params[paramIndex++];
      return this.formatValue(value);
    });

    return query;
  }

  formatValue(value) {
    if (value === null) return 'NULL';
    if (typeof value === 'string') return `'${this.escapeValue(value)}'`;
    if (typeof value === 'number') return value.toString();
    if (typeof value === 'boolean') return value ? '1' : '0';
    if (value instanceof Date) return `'${value.toISOString()}'`;

    throw new Error('Unsupported value type');
  }
}

// NoSQL Injection Prevention
class NoSQLInjectionPrevention {
  constructor() {
    this.dangerousOperators = [
      '$where',
      '$regex',
      '$ne',
      '$gt',
      '$lt',
      '$gte',
      '$lte',
      '$in',
      '$nin',
      '$exists'
    ];
  }

  detect(input) {
    if (typeof input !== 'object') {
      return null;
    }

    const detections = [];
    this.scanObject(input, detections);

    return detections.length > 0 ? detections : null;
  }

  scanObject(obj, detections, path = '') {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;

      // Check for dangerous operators
      if (this.dangerousOperators.includes(key)) {
        detections.push({
          path: currentPath,
          operator: key,
          value
        });
      }

      // Recursively scan nested objects
      if (typeof value === 'object' && value !== null) {
        this.scanObject(value, detections, currentPath);
      }
    }
  }

  sanitize(input) {
    if (typeof input !== 'object' || input === null) {
      return input;
    }

    const sanitized = {};

    for (const [key, value] of Object.entries(input)) {
      // Skip dangerous operators
      if (this.dangerousOperators.includes(key)) {
        continue;
      }

      // Recursively sanitize nested objects
      if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitize(value);
      } else {
        sanitized[key] = value;
      }
    }

    return sanitized;
  }

  escapeRegex(pattern) {
    // Escape regex special characters
    return pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

// Command Injection Prevention
class CommandInjectionPrevention {
  constructor() {
    this.dangerousCharacters = [
      ';',   // Command separator
      '|',   // Pipe
      '&',   // Background/chain
      '$',   // Variable expansion
      '`',   // Command substitution
      '\\',  // Escape character
      '\n',  // Newline
      '\r',  // Carriage return
      '<',   // Input redirection
      '>',   // Output redirection
      '(',   // Subshell
      ')',   // Subshell
      '{',   // Command grouping
      '}',   // Command grouping
      '[',   // Test command
      ']'    // Test command
    ];
  }

  detect(input) {
    const detections = [];

    for (const char of this.dangerousCharacters) {
      if (input.includes(char)) {
        detections.push({
          character: char,
          position: input.indexOf(char)
        });
      }
    }

    // Check for specific patterns
    const patterns = [
      { pattern: /\$\([^)]+\)/, name: 'command substitution' },
      { pattern: /`[^`]+`/, name: 'backtick substitution' },
      { pattern: /\${[^}]+}/, name: 'variable expansion' },
      { pattern: />>&\d+/, name: 'file descriptor manipulation' }
    ];

    for (const { pattern, name } of patterns) {
      const match = input.match(pattern);
      if (match) {
        detections.push({
          pattern: name,
          match: match[0],
          position: match.index
        });
      }
    }

    return detections.length > 0 ? detections : null;
  }

  prevent(command, args = []) {
    const { spawn } = require('child_process');

    // Use array form to prevent shell interpretation
    return {
      command,
      args: args.map(arg => this.escapeArgument(arg)),
      options: {
        shell: false  // Never use shell
      }
    };
  }

  escapeArgument(arg) {
    if (typeof arg !== 'string') {
      arg = String(arg);
    }

    // Check for dangerous characters
    for (const char of this.dangerousCharacters) {
      if (arg.includes(char)) {
        // Wrap in single quotes and escape single quotes
        return "'" + arg.replace(/'/g, "'\\''") + "'";
      }
    }

    return arg;
  }

  buildSafeCommand(executable, args) {
    // Validate executable
    if (!this.isAllowedExecutable(executable)) {
      throw new Error(`Executable not allowed: ${executable}`);
    }

    // Build command array
    return [executable, ...args.map(arg => this.escapeArgument(arg))];
  }

  isAllowedExecutable(executable) {
    const allowedExecutables = [
      'ls', 'cat', 'grep', 'find', 'echo', 'pwd',
      'date', 'whoami', 'df', 'du', 'ps', 'top'
    ];

    const path = require('path');
    const basename = path.basename(executable);

    return allowedExecutables.includes(basename);
  }
}
```

## Path Security

### Path Security Manager

```javascript
class PathSecurityManager {
  constructor() {
    this.jailRoot = process.cwd();
    this.allowedPaths = [this.jailRoot, '/tmp', '/var/tmp'];
    this.blockedPaths = [
      '/etc',
      '/sys',
      '/proc',
      '/dev',
      process.env.HOME + '/.ssh',
      process.env.HOME + '/.aws'
    ];
  }

  validatePath(requestedPath) {
    const path = require('path');

    // Normalize the path
    const normalized = path.normalize(requestedPath);

    // Resolve to absolute path
    const absolute = path.resolve(normalized);

    // Check for null bytes
    if (absolute.includes('\0')) {
      return {
        valid: false,
        error: 'Path contains null bytes'
      };
    }

    // Check for traversal
    if (this.hasTraversal(requestedPath)) {
      return {
        valid: false,
        error: 'Path traversal detected'
      };
    }

    // Check if path is within jail
    if (!this.isWithinJail(absolute)) {
      return {
        valid: false,
        error: 'Path is outside allowed directories'
      };
    }

    // Check against blocked paths
    if (this.isBlocked(absolute)) {
      return {
        valid: false,
        error: 'Path is blocked'
      };
    }

    // Check symlink
    if (this.isSymlink(absolute)) {
      const target = this.resolveSymlink(absolute);
      if (!this.isWithinJail(target)) {
        return {
          valid: false,
          error: 'Symlink points outside jail'
        };
      }
    }

    return {
      valid: true,
      normalized: absolute
    };
  }

  hasTraversal(path) {
    const patterns = [
      /\.\./,
      /\.\.%2[fF]/,
      /%2e%2e/i,
      /\.\.[\/\\]/
    ];

    return patterns.some(p => p.test(path));
  }

  isWithinJail(absolutePath) {
    return this.allowedPaths.some(allowed =>
      absolutePath.startsWith(allowed)
    );
  }

  isBlocked(absolutePath) {
    return this.blockedPaths.some(blocked =>
      absolutePath.startsWith(blocked)
    );
  }

  isSymlink(path) {
    try {
      const fs = require('fs');
      return fs.lstatSync(path).isSymbolicLink();
    } catch {
      return false;
    }
  }

  resolveSymlink(path) {
    try {
      const fs = require('fs');
      return fs.readlinkSync(path);
    } catch {
      return path;
    }
  }

  createSafePath(userInput) {
    const path = require('path');

    // Remove any traversal attempts
    let safe = userInput.replace(/\.\./g, '');

    // Remove null bytes
    safe = safe.replace(/\0/g, '');

    // Normalize
    safe = path.normalize(safe);

    // Ensure relative to jail root
    if (path.isAbsolute(safe)) {
      safe = path.relative(this.jailRoot, safe);
    }

    // Final path within jail
    return path.join(this.jailRoot, safe);
  }

  // File operation wrappers
  async safeReadFile(filepath, options = {}) {
    const validation = this.validatePath(filepath);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const fs = await import('fs/promises');
    return await fs.readFile(validation.normalized, options);
  }

  async safeWriteFile(filepath, content, options = {}) {
    const validation = this.validatePath(filepath);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    // Additional write-specific checks
    if (await this.isExecutable(validation.normalized)) {
      throw new Error('Cannot overwrite executable files');
    }

    const fs = await import('fs/promises');
    return await fs.writeFile(validation.normalized, content, options);
  }

  async isExecutable(filepath) {
    try {
      const fs = await import('fs/promises');
      const stats = await fs.stat(filepath);
      // Check if file has execute permissions
      return (stats.mode & 0o111) !== 0;
    } catch {
      return false;
    }
  }
}
```

## Command Execution Safety

### Safe Command Executor

```javascript
class SafeCommandExecutor {
  constructor() {
    this.allowedCommands = new Map();
    this.commandHistory = [];
    this.activeProcesses = new Map();

    this.initializeAllowedCommands();
  }

  initializeAllowedCommands() {
    // Define allowed commands with constraints
    this.allowedCommands.set('ls', {
      maxArgs: 10,
      allowedFlags: ['-l', '-a', '-h', '-R'],
      timeout: 5000
    });

    this.allowedCommands.set('cat', {
      maxArgs: 5,
      allowedFlags: ['-n', '-b', '-s'],
      timeout: 5000,
      maxOutputSize: 1048576 // 1MB
    });

    this.allowedCommands.set('grep', {
      maxArgs: 10,
      allowedFlags: ['-i', '-v', '-n', '-c', '-r'],
      timeout: 10000
    });

    this.allowedCommands.set('echo', {
      maxArgs: 100,
      allowedFlags: ['-n', '-e'],
      timeout: 1000
    });

    this.allowedCommands.set('pwd', {
      maxArgs: 0,
      allowedFlags: [],
      timeout: 1000
    });

    this.allowedCommands.set('whoami', {
      maxArgs: 0,
      allowedFlags: [],
      timeout: 1000
    });
  }

  async executeCommand(command, args = [], options = {}) {
    // Validate command
    const validation = this.validateCommand(command, args);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    // Check rate limiting
    if (!this.checkRateLimit(command)) {
      throw new Error('Rate limit exceeded for command');
    }

    // Create safe execution environment
    const execOptions = this.createSafeEnvironment(command, options);

    // Execute with monitoring
    const result = await this.executeWithMonitoring(
      command,
      args,
      execOptions
    );

    // Log execution
    this.logExecution(command, args, result);

    return result;
  }

  validateCommand(command, args) {
    // Check if command is allowed
    if (!this.allowedCommands.has(command)) {
      return {
        valid: false,
        error: `Command not allowed: ${command}`
      };
    }

    const config = this.allowedCommands.get(command);

    // Check argument count
    if (args.length > config.maxArgs) {
      return {
        valid: false,
        error: `Too many arguments: ${args.length} > ${config.maxArgs}`
      };
    }

    // Validate flags
    for (const arg of args) {
      if (arg.startsWith('-')) {
        if (!config.allowedFlags.includes(arg)) {
          return {
            valid: false,
            error: `Flag not allowed: ${arg}`
          };
        }
      }
    }

    // Check for injection attempts
    const injectionCheck = new CommandInjectionPrevention();
    for (const arg of args) {
      const detected = injectionCheck.detect(arg);
      if (detected) {
        return {
          valid: false,
          error: 'Potential injection detected in arguments'
        };
      }
    }

    return { valid: true };
  }

  checkRateLimit(command) {
    const now = Date.now();
    const recentExecutions = this.commandHistory.filter(
      h => h.command === command && (now - h.timestamp) < 60000
    );

    // Allow 10 executions per minute per command
    return recentExecutions.length < 10;
  }

  createSafeEnvironment(command, options) {
    const config = this.allowedCommands.get(command);

    return {
      timeout: options.timeout || config.timeout,
      maxBuffer: config.maxOutputSize || 1048576,
      shell: false,  // Never use shell
      env: this.createSafeEnv(),
      cwd: this.getSafeCwd(),
      uid: process.getuid?.(),  // Run as current user
      gid: process.getgid?.()   // Run as current group
    };
  }

  createSafeEnv() {
    // Minimal environment variables
    return {
      PATH: '/usr/bin:/bin',
      HOME: '/tmp',
      USER: 'restricted',
      LANG: 'en_US.UTF-8'
    };
  }

  getSafeCwd() {
    // Execute in temporary directory
    return '/tmp';
  }

  async executeWithMonitoring(command, args, options) {
    const { spawn } = require('child_process');

    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const processId = this.generateProcessId();

      // Spawn process
      const child = spawn(command, args, options);

      // Track active process
      this.activeProcesses.set(processId, {
        command,
        args,
        startTime,
        process: child
      });

      let stdout = '';
      let stderr = '';
      let outputSize = 0;

      // Monitor output
      child.stdout.on('data', (data) => {
        outputSize += data.length;

        // Check output size limit
        if (outputSize > options.maxBuffer) {
          child.kill('SIGTERM');
          reject(new Error('Output size limit exceeded'));
          return;
        }

        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      // Set timeout
      const timeout = setTimeout(() => {
        child.kill('SIGTERM');
        reject(new Error('Command timeout'));
      }, options.timeout);

      // Handle completion
      child.on('close', (code) => {
        clearTimeout(timeout);
        this.activeProcesses.delete(processId);

        const duration = Date.now() - startTime;

        resolve({
          stdout,
          stderr,
          exitCode: code,
          duration,
          processId
        });
      });

      child.on('error', (error) => {
        clearTimeout(timeout);
        this.activeProcesses.delete(processId);
        reject(error);
      });
    });
  }

  generateProcessId() {
    return `proc_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  }

  logExecution(command, args, result) {
    this.commandHistory.push({
      command,
      args,
      exitCode: result.exitCode,
      duration: result.duration,
      timestamp: Date.now()
    });

    // Keep only last 1000 executions
    if (this.commandHistory.length > 1000) {
      this.commandHistory.shift();
    }
  }

  killProcess(processId) {
    const processInfo = this.activeProcesses.get(processId);

    if (processInfo) {
      processInfo.process.kill('SIGKILL');
      this.activeProcesses.delete(processId);
      return true;
    }

    return false;
  }

  getActiveProcesses() {
    return Array.from(this.activeProcesses.entries()).map(([id, info]) => ({
      id,
      command: info.command,
      args: info.args,
      startTime: info.startTime,
      duration: Date.now() - info.startTime
    }));
  }
}
```

## Rate Limiting and DoS Prevention

### Rate Limiter

```javascript
class RateLimiter {
  constructor() {
    this.limits = new Map();
    this.requests = new Map();
    this.blacklist = new Set();
  }

  configureLimits() {
    // Global limits
    this.setLimit('global', {
      requests: 1000,
      window: 60000,  // 1 minute
      burst: 50
    });

    // Per-user limits
    this.setLimit('user', {
      requests: 100,
      window: 60000,
      burst: 10
    });

    // Per-IP limits
    this.setLimit('ip', {
      requests: 500,
      window: 60000,
      burst: 25
    });

    // Tool-specific limits
    this.setLimit('tool:bash', {
      requests: 10,
      window: 60000,
      burst: 3
    });

    this.setLimit('tool:write', {
      requests: 50,
      window: 60000,
      burst: 5
    });

    this.setLimit('api:messages', {
      requests: 60,
      window: 60000,
      burst: 10
    });
  }

  setLimit(key, config) {
    this.limits.set(key, {
      ...config,
      tokens: config.burst || config.requests,
      lastRefill: Date.now()
    });
  }

  async checkLimit(identifier, limitKey = 'user') {
    // Check if blacklisted
    if (this.blacklist.has(identifier)) {
      return {
        allowed: false,
        reason: 'Blacklisted',
        retryAfter: null
      };
    }

    const limit = this.limits.get(limitKey);

    if (!limit) {
      return { allowed: true };
    }

    // Get or create request tracker
    const key = `${limitKey}:${identifier}`;
    if (!this.requests.has(key)) {
      this.requests.set(key, {
        count: 0,
        tokens: limit.burst || limit.requests,
        windowStart: Date.now()
      });
    }

    const tracker = this.requests.get(key);

    // Refill tokens (token bucket algorithm)
    this.refillTokens(tracker, limit);

    // Check if request is allowed
    if (tracker.tokens > 0) {
      tracker.tokens--;
      tracker.count++;

      return {
        allowed: true,
        remaining: tracker.tokens,
        reset: tracker.windowStart + limit.window
      };
    }

    // Calculate retry time
    const retryAfter = this.calculateRetryAfter(tracker, limit);

    // Check for abuse
    if (this.isAbusive(tracker)) {
      this.blacklist.add(identifier);
    }

    return {
      allowed: false,
      reason: 'Rate limit exceeded',
      retryAfter,
      remaining: 0
    };
  }

  refillTokens(tracker, limit) {
    const now = Date.now();
    const elapsed = now - tracker.windowStart;

    // Reset window if expired
    if (elapsed >= limit.window) {
      tracker.count = 0;
      tracker.tokens = limit.burst || limit.requests;
      tracker.windowStart = now;
      return;
    }

    // Gradual token refill
    const refillRate = limit.requests / limit.window;
    const tokensToAdd = Math.floor(elapsed * refillRate);
    tracker.tokens = Math.min(
      tracker.tokens + tokensToAdd,
      limit.burst || limit.requests
    );
  }

  calculateRetryAfter(tracker, limit) {
    const timeUntilReset = (tracker.windowStart + limit.window) - Date.now();
    return Math.max(0, Math.ceil(timeUntilReset / 1000));
  }

  isAbusive(tracker) {
    // Consider abusive if hitting limits repeatedly
    return tracker.count > tracker.tokens * 3;
  }

  reset(identifier) {
    // Remove all tracking for identifier
    for (const key of this.requests.keys()) {
      if (key.includes(identifier)) {
        this.requests.delete(key);
      }
    }

    // Remove from blacklist
    this.blacklist.delete(identifier);
  }

  getStats() {
    const stats = {
      totalRequests: 0,
      blockedRequests: 0,
      blacklisted: this.blacklist.size,
      limits: {}
    };

    for (const [key, tracker] of this.requests) {
      stats.totalRequests += tracker.count;

      const [limitKey] = key.split(':');
      if (!stats.limits[limitKey]) {
        stats.limits[limitKey] = {
          requests: 0,
          blocked: 0
        };
      }

      stats.limits[limitKey].requests += tracker.count;
      if (tracker.tokens === 0) {
        stats.limits[limitKey].blocked++;
      }
    }

    return stats;
  }
}

// DoS Prevention
class DoSPrevention {
  constructor() {
    this.resourceLimits = {
      maxMemory: 512 * 1024 * 1024,     // 512MB
      maxCPUTime: 10000,                // 10 seconds
      maxProcesses: 10,
      maxFileSize: 100 * 1024 * 1024,   // 100MB
      maxOpenFiles: 100
    };

    this.monitors = new Map();
  }

  enforceResourceLimits() {
    // Monitor memory usage
    setInterval(() => {
      const usage = process.memoryUsage();

      if (usage.heapUsed > this.resourceLimits.maxMemory) {
        console.error('Memory limit exceeded');
        this.handleResourceViolation('memory', usage.heapUsed);
      }
    }, 1000);

    // Monitor CPU usage
    let lastCPU = process.cpuUsage();
    setInterval(() => {
      const currentCPU = process.cpuUsage(lastCPU);
      const cpuTime = (currentCPU.user + currentCPU.system) / 1000;

      if (cpuTime > this.resourceLimits.maxCPUTime) {
        console.error('CPU time limit exceeded');
        this.handleResourceViolation('cpu', cpuTime);
      }

      lastCPU = currentCPU;
    }, 1000);
  }

  handleResourceViolation(resource, value) {
    // Log violation
    console.error(`Resource violation: ${resource} = ${value}`);

    // Take action based on resource
    switch (resource) {
      case 'memory':
        // Force garbage collection
        if (global.gc) {
          global.gc();
        }
        break;

      case 'cpu':
        // Throttle processing
        this.throttleProcessing();
        break;
    }
  }

  throttleProcessing() {
    // Implement processing throttle
    console.log('Throttling processing due to high CPU usage');
  }

  detectPatterns(request) {
    const patterns = {
      // Rapid repeated requests
      rapidFire: this.detectRapidFire(request),

      // Large payload attacks
      largePayload: this.detectLargePayload(request),

      // Slowloris attack
      slowLoris: this.detectSlowLoris(request),

      // Resource exhaustion
      resourceExhaustion: this.detectResourceExhaustion(request)
    };

    return Object.entries(patterns)
      .filter(([_, detected]) => detected)
      .map(([pattern]) => pattern);
  }

  detectRapidFire(request) {
    const key = `${request.ip}:${request.endpoint}`;
    const now = Date.now();

    if (!this.monitors.has(key)) {
      this.monitors.set(key, []);
    }

    const monitor = this.monitors.get(key);
    monitor.push(now);

    // Keep only last minute
    const cutoff = now - 60000;
    const recent = monitor.filter(t => t > cutoff);
    this.monitors.set(key, recent);

    // Detect rapid fire (>100 requests/second)
    const lastSecond = recent.filter(t => t > now - 1000);
    return lastSecond.length > 100;
  }

  detectLargePayload(request) {
    const size = JSON.stringify(request.body || '').length;
    return size > 10 * 1024 * 1024; // 10MB
  }

  detectSlowLoris(request) {
    // Check for suspiciously slow connections
    return request.connectionTime > 30000; // 30 seconds
  }

  detectResourceExhaustion(request) {
    // Check if request would exhaust resources
    if (request.type === 'bash') {
      const dangerous = [
        'fork', 'while true', 'yes',
        '/dev/zero', '/dev/urandom'
      ];

      return dangerous.some(d =>
        request.command?.includes(d)
      );
    }

    return false;
  }
}
```

## Security Monitoring

### Security Monitor

```javascript
class SecurityMonitor {
  constructor() {
    this.events = [];
    this.alerts = [];
    this.metrics = {
      totalEvents: 0,
      securityViolations: 0,
      blockedRequests: 0,
      suspiciousActivities: 0
    };

    this.thresholds = {
      failedAuth: 5,
      violations: 10,
      suspiciousActivity: 3
    };
  }

  logEvent(event) {
    const enrichedEvent = {
      ...event,
      id: this.generateEventId(),
      timestamp: Date.now(),
      severity: this.calculateSeverity(event)
    };

    this.events.push(enrichedEvent);
    this.metrics.totalEvents++;

    // Check for patterns
    this.detectPatterns(enrichedEvent);

    // Trigger alerts if needed
    this.checkAlerts(enrichedEvent);

    // Rotate logs
    if (this.events.length > 10000) {
      this.rotateLogs();
    }
  }

  generateEventId() {
    return `sec_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  }

  calculateSeverity(event) {
    const severityMap = {
      'auth.failed': 'medium',
      'injection.detected': 'high',
      'traversal.attempt': 'high',
      'rate.limit.exceeded': 'low',
      'resource.violation': 'medium',
      'blacklist.added': 'high'
    };

    return severityMap[event.type] || 'info';
  }

  detectPatterns(event) {
    // Detect brute force
    if (event.type === 'auth.failed') {
      const recentFailures = this.events.filter(e =>
        e.type === 'auth.failed' &&
        e.userId === event.userId &&
        e.timestamp > Date.now() - 300000
      );

      if (recentFailures.length >= this.thresholds.failedAuth) {
        this.createAlert({
          type: 'brute-force',
          severity: 'critical',
          userId: event.userId,
          attempts: recentFailures.length
        });
      }
    }

    // Detect scanning
    if (event.type === 'not.found') {
      const recent404s = this.events.filter(e =>
        e.type === 'not.found' &&
        e.ip === event.ip &&
        e.timestamp > Date.now() - 60000
      );

      if (recent404s.length > 20) {
        this.createAlert({
          type: 'scanning',
          severity: 'high',
          ip: event.ip,
          attempts: recent404s.length
        });
      }
    }

    // Detect privilege escalation attempts
    if (event.type === 'permission.denied' && event.permission?.includes('admin')) {
      this.metrics.suspiciousActivities++;

      if (this.metrics.suspiciousActivities >= this.thresholds.suspiciousActivity) {
        this.createAlert({
          type: 'privilege-escalation',
          severity: 'critical',
          userId: event.userId,
          permission: event.permission
        });
      }
    }
  }

  checkAlerts(event) {
    // Check severity-based alerts
    if (event.severity === 'critical') {
      this.createAlert({
        type: 'critical-event',
        event: event
      });
    }

    // Check threshold-based alerts
    if (this.metrics.securityViolations >= this.thresholds.violations) {
      this.createAlert({
        type: 'high-violations',
        count: this.metrics.securityViolations
      });
    }
  }

  createAlert(alert) {
    const enrichedAlert = {
      ...alert,
      id: `alert_${Date.now()}`,
      timestamp: Date.now(),
      acknowledged: false
    };

    this.alerts.push(enrichedAlert);

    // Send notifications
    this.notifyAlert(enrichedAlert);
  }

  notifyAlert(alert) {
    // Would send to monitoring service
    console.error('SECURITY ALERT:', alert);

    // Could also:
    // - Send email
    // - Post to Slack
    // - Trigger PagerDuty
    // - Log to SIEM
  }

  rotateLogs() {
    // Archive old events
    const toArchive = this.events.splice(0, 5000);

    // Would write to permanent storage
    console.log(`Archiving ${toArchive.length} security events`);
  }

  getReport(timeRange = 3600000) {
    const now = Date.now();
    const recentEvents = this.events.filter(e =>
      e.timestamp > now - timeRange
    );

    const report = {
      timeRange,
      totalEvents: recentEvents.length,
      byType: {},
      bySeverity: {},
      topUsers: {},
      topIPs: {}
    };

    // Aggregate by type
    for (const event of recentEvents) {
      report.byType[event.type] = (report.byType[event.type] || 0) + 1;
      report.bySeverity[event.severity] = (report.bySeverity[event.severity] || 0) + 1;

      if (event.userId) {
        report.topUsers[event.userId] = (report.topUsers[event.userId] || 0) + 1;
      }

      if (event.ip) {
        report.topIPs[event.ip] = (report.topIPs[event.ip] || 0) + 1;
      }
    }

    // Sort top users and IPs
    report.topUsers = Object.entries(report.topUsers)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    report.topIPs = Object.entries(report.topIPs)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    return report;
  }
}
```

## Vulnerability Scanning

### Vulnerability Scanner

```javascript
class VulnerabilityScanner {
  constructor() {
    this.scanners = new Map();
    this.vulnerabilities = [];

    this.initializeScanners();
  }

  initializeScanners() {
    // Dependency scanner
    this.registerScanner('dependencies', {
      async scan() {
        const { execSync } = require('child_process');

        try {
          const result = execSync('npm audit --json', {
            encoding: 'utf8'
          });

          const audit = JSON.parse(result);

          return {
            type: 'dependencies',
            vulnerabilities: audit.vulnerabilities || {},
            severity: audit.metadata?.vulnerabilities || {}
          };

        } catch (error) {
          return {
            type: 'dependencies',
            error: error.message
          };
        }
      }
    });

    // Configuration scanner
    this.registerScanner('configuration', {
      scan() {
        const issues = [];

        // Check for default credentials
        if (process.env.DEFAULT_PASSWORD) {
          issues.push({
            severity: 'critical',
            issue: 'Default password detected'
          });
        }

        // Check for debug mode
        if (process.env.DEBUG === 'true') {
          issues.push({
            severity: 'medium',
            issue: 'Debug mode enabled in production'
          });
        }

        // Check TLS configuration
        if (!process.env.TLS_CERT) {
          issues.push({
            severity: 'high',
            issue: 'TLS not configured'
          });
        }

        return {
          type: 'configuration',
          issues
        };
      }
    });

    // Permission scanner
    this.registerScanner('permissions', {
      async scan() {
        const fs = await import('fs/promises');
        const issues = [];

        // Check file permissions
        const sensitiveFiles = [
          '.env',
          'config.json',
          'keys.json'
        ];

        for (const file of sensitiveFiles) {
          try {
            const stats = await fs.stat(file);
            const mode = (stats.mode & parseInt('777', 8)).toString(8);

            if (mode !== '600') {
              issues.push({
                severity: 'high',
                issue: `Insecure permissions on ${file}: ${mode}`
              });
            }
          } catch {
            // File doesn't exist
          }
        }

        return {
          type: 'permissions',
          issues
        };
      }
    });

    // Code scanner
    this.registerScanner('code', {
      async scan() {
        const issues = [];
        const patterns = [
          { pattern: /eval\(/g, issue: 'Use of eval()' },
          { pattern: /Function\(/g, issue: 'Use of Function constructor' },
          { pattern: /innerHTML/g, issue: 'Use of innerHTML' },
          { pattern: /document\.write/g, issue: 'Use of document.write' },
          { pattern: /\.exec\(/g, issue: 'Direct command execution' }
        ];

        // Would scan actual code files
        // For demonstration, checking common patterns

        return {
          type: 'code',
          issues
        };
      }
    });
  }

  registerScanner(name, scanner) {
    this.scanners.set(name, scanner);
  }

  async runScan(scanType = null) {
    const results = [];

    const scannersToRun = scanType
      ? [this.scanners.get(scanType)]
      : Array.from(this.scanners.values());

    for (const scanner of scannersToRun) {
      if (scanner) {
        const result = await scanner.scan();
        results.push(result);

        // Store vulnerabilities
        if (result.vulnerabilities || result.issues) {
          this.storeVulnerabilities(result);
        }
      }
    }

    return this.generateReport(results);
  }

  storeVulnerabilities(scanResult) {
    const timestamp = Date.now();

    if (scanResult.vulnerabilities) {
      for (const [name, vuln] of Object.entries(scanResult.vulnerabilities)) {
        this.vulnerabilities.push({
          type: scanResult.type,
          name,
          severity: vuln.severity,
          timestamp
        });
      }
    }

    if (scanResult.issues) {
      for (const issue of scanResult.issues) {
        this.vulnerabilities.push({
          type: scanResult.type,
          ...issue,
          timestamp
        });
      }
    }
  }

  generateReport(scanResults) {
    const report = {
      timestamp: Date.now(),
      scans: scanResults.length,
      totalVulnerabilities: 0,
      bySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      recommendations: []
    };

    // Aggregate vulnerabilities
    for (const result of scanResults) {
      if (result.vulnerabilities) {
        const vulns = Object.values(result.vulnerabilities);
        report.totalVulnerabilities += vulns.length;

        for (const vuln of vulns) {
          report.bySeverity[vuln.severity]++;
        }
      }

      if (result.issues) {
        report.totalVulnerabilities += result.issues.length;

        for (const issue of result.issues) {
          report.bySeverity[issue.severity]++;
        }
      }
    }

    // Generate recommendations
    if (report.bySeverity.critical > 0) {
      report.recommendations.push('Address critical vulnerabilities immediately');
    }

    if (report.bySeverity.high > 5) {
      report.recommendations.push('High number of high-severity issues detected');
    }

    return report;
  }

  async autoFix(vulnerability) {
    // Attempt automatic remediation
    switch (vulnerability.type) {
      case 'dependencies':
        // Run npm audit fix
        const { execSync } = require('child_process');
        try {
          execSync('npm audit fix');
          return { fixed: true };
        } catch (error) {
          return { fixed: false, error: error.message };
        }

      case 'permissions':
        // Fix file permissions
        const fs = await import('fs/promises');
        try {
          await fs.chmod(vulnerability.file, '600');
          return { fixed: true };
        } catch (error) {
          return { fixed: false, error: error.message };
        }

      default:
        return { fixed: false, error: 'No auto-fix available' };
    }
  }
}
```

## Performance Implications

### Security Performance Analysis

```javascript
class SecurityPerformanceAnalyzer {
  static async analyzePerformance() {
    const metrics = {
      validationOverhead: await this.measureValidation(),
      injectionPreventionCost: await this.measureInjectionPrevention(),
      pathSecurityOverhead: await this.measurePathSecurity(),
      rateLimitingCost: await this.measureRateLimiting(),
      monitoringOverhead: await this.measureMonitoring()
    };

    return this.generateAnalysis(metrics);
  }

  static async measureValidation() {
    const validator = new InputValidationFramework();
    const testInput = 'echo "test command"';

    const iterations = 10000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      await validator.validate(testInput, 'command');
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measureInjectionPrevention() {
    const sqlPrevention = new SQLInjectionPrevention();
    const testQuery = 'SELECT * FROM users WHERE id = ?';
    const testParams = ['123'];

    const iterations = 10000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      sqlPrevention.prevent(testQuery, testParams);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measurePathSecurity() {
    const pathManager = new PathSecurityManager();
    const testPath = '/tmp/test/file.txt';

    const iterations = 10000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      pathManager.validatePath(testPath);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measureRateLimiting() {
    const rateLimiter = new RateLimiter();
    rateLimiter.configureLimits();

    const testIdentifier = 'test-user';

    const iterations = 1000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      await rateLimiter.checkLimit(testIdentifier);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measureMonitoring() {
    const monitor = new SecurityMonitor();
    const testEvent = {
      type: 'auth.attempt',
      userId: 'test-user',
      ip: '192.168.1.1'
    };

    const iterations = 1000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      monitor.logEvent(testEvent);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static generateAnalysis(metrics) {
    const analysis = {
      metrics,
      totalOverhead: Object.values(metrics).reduce((sum, val) => sum + val, 0),
      recommendations: [],
      performanceGrade: 'A'
    };

    // Generate recommendations
    if (metrics.validationOverhead > 0.5) {
      analysis.recommendations.push('Consider caching validation results');
    }

    if (metrics.injectionPreventionCost > 0.3) {
      analysis.recommendations.push('Use prepared statements for better performance');
    }

    if (metrics.pathSecurityOverhead > 0.2) {
      analysis.recommendations.push('Implement path validation caching');
    }

    if (metrics.rateLimitingCost > 0.5) {
      analysis.recommendations.push('Use Redis for distributed rate limiting');
    }

    if (metrics.monitoringOverhead > 1.0) {
      analysis.recommendations.push('Consider async logging for monitoring');
    }

    // Calculate performance grade
    if (analysis.totalOverhead > 5) {
      analysis.performanceGrade = 'C';
    } else if (analysis.totalOverhead > 2) {
      analysis.performanceGrade = 'B';
    }

    return analysis;
  }
}
```

## Summary

Claude Code's vulnerability prevention system provides:

1. **Comprehensive Input Validation**: Multi-layer validation with type-specific rules
2. **Injection Attack Prevention**: SQL, NoSQL, and command injection protection
3. **Path Security**: Jail-based path restrictions with traversal prevention
4. **Safe Command Execution**: Whitelisted commands with resource limits
5. **Rate Limiting**: Token bucket algorithm with abuse detection
6. **DoS Prevention**: Resource monitoring and attack pattern detection
7. **Security Monitoring**: Real-time threat detection and alerting
8. **Vulnerability Scanning**: Automated security assessment and remediation

The system proactively prevents common vulnerabilities while maintaining performance and usability.

## Next Steps

This completes Part 10: Security. The next part will explore Extensibility features of the Claude Code system.

---

*Part of the Claude Code Technical Series - Security*