# 第10.4部分：漏洞预防

## 介绍

Claude Code中的漏洞预防包含主动安全措施，以防止常见的攻击向量，包括注入攻击、路径遍历、权限提升和拒绝服务。本章探讨了保护整个系统免受安全漏洞侵害的全面防御机制。

## 目录
1. [输入验证框架](#输入验证框架)
2. [注入攻击预防](#注入攻击预防)
3. [路径安全](#路径安全)
4. [命令执行安全](#命令执行安全)
5. [速率限制和DoS预防](#速率限制和dos预防)
6. [安全监控](#安全监控)
7. [漏洞扫描](#漏洞扫描)
8. [性能影响](#性能影响)

## 输入验证框架

### 综合输入验证器

```javascript
class InputValidationFramework {
  constructor() {
    this.validators = new Map();
    this.schemas = new Map();
    this.blacklists = new Map();
    this.whitelists = new Map();

    this.initializeValidators();
  }

  initializeValidators() {
    // 命令输入验证器
    this.registerValidator('command', {
      type: 'string',
      maxLength: 1024,
      pattern: /^[a-zA-Z0-9\s\-_.\/]+$/,

      validate(input) {
        // 长度检查
        if (input.length > this.maxLength) {
          return {
            valid: false,
            error: `命令超过最大长度 ${this.maxLength}`
          };
        }

        // 字符验证
        if (!this.pattern.test(input)) {
          return {
            valid: false,
            error: '命令包含无效字符'
          };
        }

        // 黑名单检查
        const blacklisted = this.checkBlacklist(input);
        if (blacklisted) {
          return {
            valid: false,
            error: `黑名单命令: ${blacklisted}`
          };
        }

        return { valid: true };
      },

      checkBlacklist(input) {
        const blacklist = [
          'rm -rf /',
          'format c:',
          ':(){ :|:& };:',  // Fork炸弹
          'dd if=/dev/zero',
          'mkfs',
          'fdisk'
        ];

        for (const dangerous of blacklist) {
          if (input.includes(dangerous)) {
            return dangerous;
          }
        }

        return null;
      },

      sanitize(input) {
        // 删除危险模式
        let sanitized = input;

        // 删除反引号
        sanitized = sanitized.replace(/`/g, '');

        // 删除命令替换
        sanitized = sanitized.replace(/\$\([^)]*\)/g, '');
        sanitized = sanitized.replace(/\${[^}]*}/g, '');

        // 删除重定向
        sanitized = sanitized.replace(/[<>]/g, '');

        // 删除管道链
        sanitized = sanitized.replace(/\|{2,}/g, '|');

        return sanitized;
      }
    });

    // 文件路径验证器
    this.registerValidator('filepath', {
      type: 'string',
      maxLength: 4096,

      validate(input) {
        const path = require('path');

        // 长度检查
        if (input.length > this.maxLength) {
          return {
            valid: false,
            error: '路径超过最大长度'
          };
        }

        // 空字节检查
        if (input.includes('\0')) {
          return {
            valid: false,
            error: '路径包含空字节'
          };
        }

        // 路径遍历检查
        if (this.hasPathTraversal(input)) {
          return {
            valid: false,
            error: '检测到路径遍历'
          };
        }

        // 规范化和验证
        const normalized = path.normalize(input);
        const resolved = path.resolve(normalized);

        // 检查路径是否在允许目录内
        if (!this.isAllowedPath(resolved)) {
          return {
            valid: false,
            error: '路径在允许目录之外'
          };
        }

        return { valid: true };
      },

      hasPathTraversal(input) {
        const patterns = [
          /\.\./,           // 父目录
          /\.\.%2[fF]/,     // URL编码
          /\.\.[\/\\]/,     // 带分隔符
          /^~/              // 主目录
        ];

        return patterns.some(p => p.test(input));
      },

      isAllowedPath(resolvedPath) {
        const allowedPaths = [
          process.cwd(),
          '/tmp',
          '/var/tmp'
        ];

        return allowedPaths.some(allowed =>
          resolvedPath.startsWith(allowed)
        );
      },

      sanitize(input) {
        const path = require('path');

        // 删除遍历序列
        let sanitized = input.replace(/\.\./g, '');

        // 删除空字节
        sanitized = sanitized.replace(/\0/g, '');

        // 规范化路径
        sanitized = path.normalize(sanitized);

        return sanitized;
      }
    });

    // URL验证器
    this.registerValidator('url', {
      type: 'string',
      protocols: ['http', 'https'],

      validate(input) {
        try {
          const url = new URL(input);

          // 协议检查
          if (!this.protocols.includes(url.protocol.slice(0, -1))) {
            return {
              valid: false,
              error: `无效协议: ${url.protocol}`
            };
          }

          // SSRF预防
          if (this.isLocalURL(url)) {
            return {
              valid: false,
              error: '不允许本地URL'
            };
          }

          // 端口限制
          const blockedPorts = [22, 23, 25, 445, 3389];
          if (blockedPorts.includes(parseInt(url.port))) {
            return {
              valid: false,
              error: `被阻止的端口: ${url.port}`
            };
          }

          return { valid: true };

        } catch (error) {
          return {
            valid: false,
            error: '无效的URL格式'
          };
        }
      },

      isLocalURL(url) {
        const localPatterns = [
          /^localhost$/i,
          /^127\./,
          /^10\./,
          /^172\.(1[6-9]|2[0-9]|3[01])\./,
          /^192\.168\./,
          /^169\.254\./,  // 链路本地
          /^::1$/,         // IPv6本地主机
          /^fc00:/,        // IPv6私有
          /^fe80:/         // IPv6链路本地
        ];

        return localPatterns.some(p => p.test(url.hostname));
      },

      sanitize(input) {
        try {
          const url = new URL(input);

          // 删除凭据
          url.username = '';
          url.password = '';

          // 在某些上下文中删除片段
          url.hash = '';

          return url.toString();

        } catch {
          return '';
        }
      }
    });

    // 内容验证器
    this.registerValidator('content', {
      type: 'string',
      maxLength: 1048576, // 1MB

      validate(input) {
        // 大小检查
        if (input.length > this.maxLength) {
          return {
            valid: false,
            error: '内容超过最大大小'
          };
        }

        // 二进制内容检查
        if (this.hasBinaryContent(input)) {
          return {
            valid: false,
            error: '不允许二进制内容'
          };
        }

        // 脚本注入检查
        if (this.hasScriptInjection(input)) {
          return {
            valid: false,
            error: '检测到脚本注入'
          };
        }

        return { valid: true };
      },

      hasBinaryContent(input) {
        // 检查非打印字符
        return /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/.test(input);
      },

      hasScriptInjection(input) {
        const patterns = [
          /<script[^>]*>/i,
          /<iframe[^>]*>/i,
          /javascript:/i,
          /on\w+\s*=/i,  // 事件处理器
          /<embed[^>]*>/i,
          /<object[^>]*>/i
        ];

        return patterns.some(p => p.test(input));
      },

      sanitize(input) {
        // 删除脚本
        let sanitized = input.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');

        // 删除事件处理器
        sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');

        // 转义HTML实体
        sanitized = sanitized
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#x27;');

        return sanitized;
      }
    });
  }

  registerValidator(name, validator) {
    this.validators.set(name, validator);
  }

  async validate(input, type, options = {}) {
    const validator = this.validators.get(type);

    if (!validator) {
      throw new Error(`未知验证器类型: ${type}`);
    }

    // 运行验证
    const result = validator.validate.call(validator, input);

    if (!result.valid) {
      // 记录验证失败
      await this.logValidationFailure(type, input, result.error);

      if (options.throwOnError) {
        throw new ValidationError(result.error);
      }
    }

    // 如果有效且请求，则净化
    if (result.valid && options.sanitize) {
      result.sanitized = validator.sanitize.call(validator, input);
    }

    return result;
  }

  async logValidationFailure(type, input, error) {
    // 将记录到安全监控
    console.warn('验证失败:', {
      type,
      error,
      timestamp: Date.now()
    });
  }
}

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

## 注入攻击预防

### SQL注入预防

```javascript
class SQLInjectionPrevention {
  constructor() {
    this.patterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|CREATE|ALTER)\b)/gi,
      /(\b(OR|AND)\b\s*\d+\s*=\s*\d+)/gi,  // OR 1=1
      /(--|\#|\/\*|\*\/)/g,  // 注释
      /(\bEXEC(UTE)?\b|\bSP_\w+)/gi,  // 存储过程
      /(\bXP_\w+)/gi,  // 扩展过程
      /(;|\||&&)/g  // 命令分隔符
    ];
  }

  detect(input) {
    const detections = [];

    for (const pattern of this.patterns) {
      const matches = input.match(pattern);
      if (matches) {
        detections.push({
          pattern: pattern.toString(),
          matches
        });
      }
    }

    return detections.length > 0 ? detections : null;
  }

  prevent(query, params = []) {
    // 使用参数化查询
    return {
      text: query,
      values: params.map(p => this.escapeValue(p))
    };
  }

  escapeValue(value) {
    if (value === null || value === undefined) {
      return null;
    }

    if (typeof value === 'string') {
      // 转义单引号
      return value.replace(/'/g, "''");
    }

    if (typeof value === 'number') {
      // 验证数字
      if (!isFinite(value)) {
        throw new Error('无效的数字值');
      }
      return value;
    }

    if (value instanceof Date) {
      return value.toISOString();
    }

    // 不允许其他类型
    throw new Error(`不支持的值类型: ${typeof value}`);
  }

  buildSafeQuery(template, params) {
    // 用转义值替换占位符
    let query = template;
    let paramIndex = 0;

    query = query.replace(/\?/g, () => {
      if (paramIndex >= params.length) {
        throw new Error('参数不足');
      }

      const value = params[paramIndex++];
      return this.formatValue(value);
    });

    return query;
  }

  formatValue(value) {
    if (value === null) return 'NULL';
    if (typeof value === 'string') return `'${this.escapeValue(value)}'`;
    if (typeof value === 'number') return value.toString();
    if (typeof value === 'boolean') return value ? '1' : '0';
    if (value instanceof Date) return `'${value.toISOString()}'`;

    throw new Error('不支持的值类型');
  }
}

// NoSQL注入预防
class NoSQLInjectionPrevention {
  constructor() {
    this.dangerousOperators = [
      '$where',
      '$regex',
      '$ne',
      '$gt',
      '$lt',
      '$gte',
      '$lte',
      '$in',
      '$nin',
      '$exists'
    ];
  }

  detect(input) {
    if (typeof input !== 'object') {
      return null;
    }

    const detections = [];
    this.scanObject(input, detections);

    return detections.length > 0 ? detections : null;
  }

  scanObject(obj, detections, path = '') {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;

      // 检查危险操作符
      if (this.dangerousOperators.includes(key)) {
        detections.push({
          path: currentPath,
          operator: key,
          value
        });
      }

      // 递归扫描嵌套对象
      if (typeof value === 'object' && value !== null) {
        this.scanObject(value, detections, currentPath);
      }
    }
  }

  sanitize(input) {
    if (typeof input !== 'object' || input === null) {
      return input;
    }

    const sanitized = {};

    for (const [key, value] of Object.entries(input)) {
      // 跳过危险操作符
      if (this.dangerousOperators.includes(key)) {
        continue;
      }

      // 递归净化嵌套对象
      if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitize(value);
      } else {
        sanitized[key] = value;
      }
    }

    return sanitized;
  }

  escapeRegex(pattern) {
    // 转义正则表达式特殊字符
    return pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

// 命令注入预防
class CommandInjectionPrevention {
  constructor() {
    this.dangerousCharacters = [
      ';',   // 命令分隔符
      '|',   // 管道
      '&',   // 后台/链式
      '$',   // 变量扩展
      '`',   // 命令替换
      '\\',  // 转义字符
      '\n',  // 换行
      '\r',  // 回车
      '<',   // 输入重定向
      '>',   // 输出重定向
      '(',   // 子shell
      ')',   // 子shell
      '{',   // 命令分组
      '}',   // 命令分组
      '[',   // 测试命令
      ']'    // 测试命令
    ];
  }

  detect(input) {
    const detections = [];

    for (const char of this.dangerousCharacters) {
      if (input.includes(char)) {
        detections.push({
          character: char,
          position: input.indexOf(char)
        });
      }
    }

    // 检查特定模式
    const patterns = [
      { pattern: /\$\([^)]+\)/, name: '命令替换' },
      { pattern: /`[^`]+`/, name: '反引号替换' },
      { pattern: /\${[^}]+}/, name: '变量扩展' },
      { pattern: />>&\d+/, name: '文件描述符操作' }
    ];

    for (const { pattern, name } of patterns) {
      const match = input.match(pattern);
      if (match) {
        detections.push({
          pattern: name,
          match: match[0],
          position: match.index
        });
      }
    }

    return detections.length > 0 ? detections : null;
  }

  prevent(command, args = []) {
    const { spawn } = require('child_process');

    // 使用数组形式防止shell解释
    return {
      command,
      args: args.map(arg => this.escapeArgument(arg)),
      options: {
        shell: false  // 永不使用shell
      }
    };
  }

  escapeArgument(arg) {
    if (typeof arg !== 'string') {
      arg = String(arg);
    }

    // 检查危险字符
    for (const char of this.dangerousCharacters) {
      if (arg.includes(char)) {
        // 用单引号括起并转义单引号
        return "'" + arg.replace(/'/g, "'\\''") + "'";
      }
    }

    return arg;
  }

  buildSafeCommand(executable, args) {
    // 验证可执行文件
    if (!this.isAllowedExecutable(executable)) {
      throw new Error(`不允许的可执行文件: ${executable}`);
    }

    // 构建命令数组
    return [executable, ...args.map(arg => this.escapeArgument(arg))];
  }

  isAllowedExecutable(executable) {
    const allowedExecutables = [
      'ls', 'cat', 'grep', 'find', 'echo', 'pwd',
      'date', 'whoami', 'df', 'du', 'ps', 'top'
    ];

    const path = require('path');
    const basename = path.basename(executable);

    return allowedExecutables.includes(basename);
  }
}
```

## 路径安全

### 路径安全管理器

```javascript
class PathSecurityManager {
  constructor() {
    this.jailRoot = process.cwd();
    this.allowedPaths = [this.jailRoot, '/tmp', '/var/tmp'];
    this.blockedPaths = [
      '/etc',
      '/sys',
      '/proc',
      '/dev',
      process.env.HOME + '/.ssh',
      process.env.HOME + '/.aws'
    ];
  }

  validatePath(requestedPath) {
    const path = require('path');

    // 规范化路径
    const normalized = path.normalize(requestedPath);

    // 解析为绝对路径
    const absolute = path.resolve(normalized);

    // 检查空字节
    if (absolute.includes('\0')) {
      return {
        valid: false,
        error: '路径包含空字节'
      };
    }

    // 检查遍历
    if (this.hasTraversal(requestedPath)) {
      return {
        valid: false,
        error: '检测到路径遍历'
      };
    }

    // 检查路径是否在监狱内
    if (!this.isWithinJail(absolute)) {
      return {
        valid: false,
        error: '路径在允许目录之外'
      };
    }

    // 检查阻止路径
    if (this.isBlocked(absolute)) {
      return {
        valid: false,
        error: '路径被阻止'
      };
    }

    // 检查符号链接
    if (this.isSymlink(absolute)) {
      const target = this.resolveSymlink(absolute);
      if (!this.isWithinJail(target)) {
        return {
          valid: false,
          error: '符号链接指向监狱外'
        };
      }
    }

    return {
      valid: true,
      normalized: absolute
    };
  }

  hasTraversal(path) {
    const patterns = [
      /\.\./,
      /\.\.%2[fF]/,
      /%2e%2e/i,
      /\.\.[\/\\]/
    ];

    return patterns.some(p => p.test(path));
  }

  isWithinJail(absolutePath) {
    return this.allowedPaths.some(allowed =>
      absolutePath.startsWith(allowed)
    );
  }

  isBlocked(absolutePath) {
    return this.blockedPaths.some(blocked =>
      absolutePath.startsWith(blocked)
    );
  }

  isSymlink(path) {
    try {
      const fs = require('fs');
      return fs.lstatSync(path).isSymbolicLink();
    } catch {
      return false;
    }
  }

  resolveSymlink(path) {
    try {
      const fs = require('fs');
      return fs.readlinkSync(path);
    } catch {
      return path;
    }
  }

  createSafePath(userInput) {
    const path = require('path');

    // 删除任何遍历尝试
    let safe = userInput.replace(/\.\./g, '');

    // 删除空字节
    safe = safe.replace(/\0/g, '');

    // 规范化
    safe = path.normalize(safe);

    // 确保相对于监狱根
    if (path.isAbsolute(safe)) {
      safe = path.relative(this.jailRoot, safe);
    }

    // 监狱内的最终路径
    return path.join(this.jailRoot, safe);
  }

  // 文件操作包装器
  async safeReadFile(filepath, options = {}) {
    const validation = this.validatePath(filepath);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const fs = await import('fs/promises');
    return await fs.readFile(validation.normalized, options);
  }

  async safeWriteFile(filepath, content, options = {}) {
    const validation = this.validatePath(filepath);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    // 额外的写入特定检查
    if (await this.isExecutable(validation.normalized)) {
      throw new Error('无法覆盖可执行文件');
    }

    const fs = await import('fs/promises');
    return await fs.writeFile(validation.normalized, content, options);
  }

  async isExecutable(filepath) {
    try {
      const fs = await import('fs/promises');
      const stats = await fs.stat(filepath);
      // 检查文件是否有执行权限
      return (stats.mode & 0o111) !== 0;
    } catch {
      return false;
    }
  }
}
```

## 命令执行安全

### 安全命令执行器

```javascript
class SafeCommandExecutor {
  constructor() {
    this.allowedCommands = new Map();
    this.commandHistory = [];
    this.activeProcesses = new Map();

    this.initializeAllowedCommands();
  }

  initializeAllowedCommands() {
    // 定义允许的命令及约束
    this.allowedCommands.set('ls', {
      maxArgs: 10,
      allowedFlags: ['-l', '-a', '-h', '-R'],
      timeout: 5000
    });

    this.allowedCommands.set('cat', {
      maxArgs: 5,
      allowedFlags: ['-n', '-b', '-s'],
      timeout: 5000,
      maxOutputSize: 1048576 // 1MB
    });

    this.allowedCommands.set('grep', {
      maxArgs: 10,
      allowedFlags: ['-i', '-v', '-n', '-c', '-r'],
      timeout: 10000
    });

    this.allowedCommands.set('echo', {
      maxArgs: 100,
      allowedFlags: ['-n', '-e'],
      timeout: 1000
    });

    this.allowedCommands.set('pwd', {
      maxArgs: 0,
      allowedFlags: [],
      timeout: 1000
    });

    this.allowedCommands.set('whoami', {
      maxArgs: 0,
      allowedFlags: [],
      timeout: 1000
    });
  }

  async executeCommand(command, args = [], options = {}) {
    // 验证命令
    const validation = this.validateCommand(command, args);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    // 检查速率限制
    if (!this.checkRateLimit(command)) {
      throw new Error('命令速率限制超过');
    }

    // 创建安全执行环境
    const execOptions = this.createSafeEnvironment(command, options);

    // 使用监控执行
    const result = await this.executeWithMonitoring(
      command,
      args,
      execOptions
    );

    // 记录执行
    this.logExecution(command, args, result);

    return result;
  }

  validateCommand(command, args) {
    // 检查命令是否允许
    if (!this.allowedCommands.has(command)) {
      return {
        valid: false,
        error: `不允许的命令: ${command}`
      };
    }

    const config = this.allowedCommands.get(command);

    // 检查参数数量
    if (args.length > config.maxArgs) {
      return {
        valid: false,
        error: `参数过多: ${args.length} > ${config.maxArgs}`
      };
    }

    // 验证标志
    for (const arg of args) {
      if (arg.startsWith('-')) {
        if (!config.allowedFlags.includes(arg)) {
          return {
            valid: false,
            error: `不允许的标志: ${arg}`
          };
        }
      }
    }

    // 检查注入尝试
    const injectionCheck = new CommandInjectionPrevention();
    for (const arg of args) {
      const detected = injectionCheck.detect(arg);
      if (detected) {
        return {
          valid: false,
          error: '在参数中检测到潜在注入'
        };
      }
    }

    return { valid: true };
  }

  checkRateLimit(command) {
    const now = Date.now();
    const recentExecutions = this.commandHistory.filter(
      h => h.command === command && (now - h.timestamp) < 60000
    );

    // 每分钟每个命令允许10次执行
    return recentExecutions.length < 10;
  }

  createSafeEnvironment(command, options) {
    const config = this.allowedCommands.get(command);

    return {
      timeout: options.timeout || config.timeout,
      maxBuffer: config.maxOutputSize || 1048576,
      shell: false,  // 永不使用shell
      env: this.createSafeEnv(),
      cwd: this.getSafeCwd(),
      uid: process.getuid?.(),  // 以当前用户运行
      gid: process.getgid?.()   // 以当前组运行
    };
  }

  createSafeEnv() {
    // 最小环境变量
    return {
      PATH: '/usr/bin:/bin',
      HOME: '/tmp',
      USER: 'restricted',
      LANG: 'en_US.UTF-8'
    };
  }

  getSafeCwd() {
    // 在临时目录中执行
    return '/tmp';
  }

  async executeWithMonitoring(command, args, options) {
    const { spawn } = require('child_process');

    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const processId = this.generateProcessId();

      // 生成进程
      const child = spawn(command, args, options);

      // 跟踪活动进程
      this.activeProcesses.set(processId, {
        command,
        args,
        startTime,
        process: child
      });

      let stdout = '';
      let stderr = '';
      let outputSize = 0;

      // 监控输出
      child.stdout.on('data', (data) => {
        outputSize += data.length;

        // 检查输出大小限制
        if (outputSize > options.maxBuffer) {
          child.kill('SIGTERM');
          reject(new Error('输出大小限制超过'));
          return;
        }

        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      // 设置超时
      const timeout = setTimeout(() => {
        child.kill('SIGTERM');
        reject(new Error('命令超时'));
      }, options.timeout);

      // 处理完成
      child.on('close', (code) => {
        clearTimeout(timeout);
        this.activeProcesses.delete(processId);

        const duration = Date.now() - startTime;

        resolve({
          stdout,
          stderr,
          exitCode: code,
          duration,
          processId
        });
      });

      child.on('error', (error) => {
        clearTimeout(timeout);
        this.activeProcesses.delete(processId);
        reject(error);
      });
    });
  }

  generateProcessId() {
    return `proc_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  }

  logExecution(command, args, result) {
    this.commandHistory.push({
      command,
      args,
      exitCode: result.exitCode,
      duration: result.duration,
      timestamp: Date.now()
    });

    // 只保留最后1000次执行
    if (this.commandHistory.length > 1000) {
      this.commandHistory.shift();
    }
  }

  killProcess(processId) {
    const processInfo = this.activeProcesses.get(processId);

    if (processInfo) {
      processInfo.process.kill('SIGKILL');
      this.activeProcesses.delete(processId);
      return true;
    }

    return false;
  }

  getActiveProcesses() {
    return Array.from(this.activeProcesses.entries()).map(([id, info]) => ({
      id,
      command: info.command,
      args: info.args,
      startTime: info.startTime,
      duration: Date.now() - info.startTime
    }));
  }
}
```

## 速率限制和DoS预防

### 速率限制器

```javascript
class RateLimiter {
  constructor() {
    this.limits = new Map();
    this.requests = new Map();
    this.blacklist = new Set();
  }

  configureLimits() {
    // 全局限制
    this.setLimit('global', {
      requests: 1000,
      window: 60000,  // 1分钟
      burst: 50
    });

    // 每用户限制
    this.setLimit('user', {
      requests: 100,
      window: 60000,
      burst: 10
    });

    // 每IP限制
    this.setLimit('ip', {
      requests: 500,
      window: 60000,
      burst: 25
    });

    // 工具特定限制
    this.setLimit('tool:bash', {
      requests: 10,
      window: 60000,
      burst: 3
    });

    this.setLimit('tool:write', {
      requests: 50,
      window: 60000,
      burst: 5
    });

    this.setLimit('api:messages', {
      requests: 60,
      window: 60000,
      burst: 10
    });
  }

  setLimit(key, config) {
    this.limits.set(key, {
      ...config,
      tokens: config.burst || config.requests,
      lastRefill: Date.now()
    });
  }

  async checkLimit(identifier, limitKey = 'user') {
    // 检查是否在黑名单中
    if (this.blacklist.has(identifier)) {
      return {
        allowed: false,
        reason: '已列入黑名单',
        retryAfter: null
      };
    }

    const limit = this.limits.get(limitKey);

    if (!limit) {
      return { allowed: true };
    }

    // 获取或创建请求跟踪器
    const key = `${limitKey}:${identifier}`;
    if (!this.requests.has(key)) {
      this.requests.set(key, {
        count: 0,
        tokens: limit.burst || limit.requests,
        windowStart: Date.now()
      });
    }

    const tracker = this.requests.get(key);

    // 补充令牌（令牌桶算法）
    this.refillTokens(tracker, limit);

    // 检查是否允许请求
    if (tracker.tokens > 0) {
      tracker.tokens--;
      tracker.count++;

      return {
        allowed: true,
        remaining: tracker.tokens,
        reset: tracker.windowStart + limit.window
      };
    }

    // 计算重试时间
    const retryAfter = this.calculateRetryAfter(tracker, limit);

    // 检查滥用
    if (this.isAbusive(tracker)) {
      this.blacklist.add(identifier);
    }

    return {
      allowed: false,
      reason: '速率限制超过',
      retryAfter,
      remaining: 0
    };
  }

  refillTokens(tracker, limit) {
    const now = Date.now();
    const elapsed = now - tracker.windowStart;

    // 如果窗口过期则重置
    if (elapsed >= limit.window) {
      tracker.count = 0;
      tracker.tokens = limit.burst || limit.requests;
      tracker.windowStart = now;
      return;
    }

    // 渐进式令牌补充
    const refillRate = limit.requests / limit.window;
    const tokensToAdd = Math.floor(elapsed * refillRate);
    tracker.tokens = Math.min(
      tracker.tokens + tokensToAdd,
      limit.burst || limit.requests
    );
  }

  calculateRetryAfter(tracker, limit) {
    const timeUntilReset = (tracker.windowStart + limit.window) - Date.now();
    return Math.max(0, Math.ceil(timeUntilReset / 1000));
  }

  isAbusive(tracker) {
    // 如果重复达到限制则认为是滥用
    return tracker.count > tracker.tokens * 3;
  }

  reset(identifier) {
    // 删除标识符的所有跟踪
    for (const key of this.requests.keys()) {
      if (key.includes(identifier)) {
        this.requests.delete(key);
      }
    }

    // 从黑名单中删除
    this.blacklist.delete(identifier);
  }

  getStats() {
    const stats = {
      totalRequests: 0,
      blockedRequests: 0,
      blacklisted: this.blacklist.size,
      limits: {}
    };

    for (const [key, tracker] of this.requests) {
      stats.totalRequests += tracker.count;

      const [limitKey] = key.split(':');
      if (!stats.limits[limitKey]) {
        stats.limits[limitKey] = {
          requests: 0,
          blocked: 0
        };
      }

      stats.limits[limitKey].requests += tracker.count;
      if (tracker.tokens === 0) {
        stats.limits[limitKey].blocked++;
      }
    }

    return stats;
  }
}

// DoS预防
class DoSPrevention {
  constructor() {
    this.resourceLimits = {
      maxMemory: 512 * 1024 * 1024,     // 512MB
      maxCPUTime: 10000,                // 10秒
      maxProcesses: 10,
      maxFileSize: 100 * 1024 * 1024,   // 100MB
      maxOpenFiles: 100
    };

    this.monitors = new Map();
  }

  enforceResourceLimits() {
    // 监控内存使用
    setInterval(() => {
      const usage = process.memoryUsage();

      if (usage.heapUsed > this.resourceLimits.maxMemory) {
        console.error('内存限制超过');
        this.handleResourceViolation('memory', usage.heapUsed);
      }
    }, 1000);

    // 监控CPU使用
    let lastCPU = process.cpuUsage();
    setInterval(() => {
      const currentCPU = process.cpuUsage(lastCPU);
      const cpuTime = (currentCPU.user + currentCPU.system) / 1000;

      if (cpuTime > this.resourceLimits.maxCPUTime) {
        console.error('CPU时间限制超过');
        this.handleResourceViolation('cpu', cpuTime);
      }

      lastCPU = currentCPU;
    }, 1000);
  }

  handleResourceViolation(resource, value) {
    // 记录违规
    console.error(`资源违规: ${resource} = ${value}`);

    // 根据资源采取行动
    switch (resource) {
      case 'memory':
        // 强制垃圾收集
        if (global.gc) {
          global.gc();
        }
        break;

      case 'cpu':
        // 节流处理
        this.throttleProcessing();
        break;
    }
  }

  throttleProcessing() {
    // 实施处理节流
    console.log('由于高CPU使用率而节流处理');
  }

  detectPatterns(request) {
    const patterns = {
      // 快速重复请求
      rapidFire: this.detectRapidFire(request),

      // 大负载攻击
      largePayload: this.detectLargePayload(request),

      // Slowloris攻击
      slowLoris: this.detectSlowLoris(request),

      // 资源耗尽
      resourceExhaustion: this.detectResourceExhaustion(request)
    };

    return Object.entries(patterns)
      .filter(([_, detected]) => detected)
      .map(([pattern]) => pattern);
  }

  detectRapidFire(request) {
    const key = `${request.ip}:${request.endpoint}`;
    const now = Date.now();

    if (!this.monitors.has(key)) {
      this.monitors.set(key, []);
    }

    const monitor = this.monitors.get(key);
    monitor.push(now);

    // 只保留最后一分钟
    const cutoff = now - 60000;
    const recent = monitor.filter(t => t > cutoff);
    this.monitors.set(key, recent);

    // 检测快速发射（>100请求/秒）
    const lastSecond = recent.filter(t => t > now - 1000);
    return lastSecond.length > 100;
  }

  detectLargePayload(request) {
    const size = JSON.stringify(request.body || '').length;
    return size > 10 * 1024 * 1024; // 10MB
  }

  detectSlowLoris(request) {
    // 检查可疑的慢速连接
    return request.connectionTime > 30000; // 30秒
  }

  detectResourceExhaustion(request) {
    // 检查请求是否会耗尽资源
    if (request.type === 'bash') {
      const dangerous = [
        'fork', 'while true', 'yes',
        '/dev/zero', '/dev/urandom'
      ];

      return dangerous.some(d =>
        request.command?.includes(d)
      );
    }

    return false;
  }
}
```

## 安全监控

### 安全监视器

```javascript
class SecurityMonitor {
  constructor() {
    this.events = [];
    this.alerts = [];
    this.metrics = {
      totalEvents: 0,
      securityViolations: 0,
      blockedRequests: 0,
      suspiciousActivities: 0
    };

    this.thresholds = {
      failedAuth: 5,
      violations: 10,
      suspiciousActivity: 3
    };
  }

  logEvent(event) {
    const enrichedEvent = {
      ...event,
      id: this.generateEventId(),
      timestamp: Date.now(),
      severity: this.calculateSeverity(event)
    };

    this.events.push(enrichedEvent);
    this.metrics.totalEvents++;

    // 检查模式
    this.detectPatterns(enrichedEvent);

    // 如果需要触发警报
    this.checkAlerts(enrichedEvent);

    // 轮换日志
    if (this.events.length > 10000) {
      this.rotateLogs();
    }
  }

  generateEventId() {
    return `sec_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  }

  calculateSeverity(event) {
    const severityMap = {
      'auth.failed': '中等',
      'injection.detected': '高',
      'traversal.attempt': '高',
      'rate.limit.exceeded': '低',
      'resource.violation': '中等',
      'blacklist.added': '高'
    };

    return severityMap[event.type] || '信息';
  }

  detectPatterns(event) {
    // 检测暴力破解
    if (event.type === 'auth.failed') {
      const recentFailures = this.events.filter(e =>
        e.type === 'auth.failed' &&
        e.userId === event.userId &&
        e.timestamp > Date.now() - 300000
      );

      if (recentFailures.length >= this.thresholds.failedAuth) {
        this.createAlert({
          type: '暴力破解',
          severity: '关键',
          userId: event.userId,
          attempts: recentFailures.length
        });
      }
    }

    // 检测扫描
    if (event.type === 'not.found') {
      const recent404s = this.events.filter(e =>
        e.type === 'not.found' &&
        e.ip === event.ip &&
        e.timestamp > Date.now() - 60000
      );

      if (recent404s.length > 20) {
        this.createAlert({
          type: '扫描',
          severity: '高',
          ip: event.ip,
          attempts: recent404s.length
        });
      }
    }

    // 检测权限提升尝试
    if (event.type === 'permission.denied' && event.permission?.includes('admin')) {
      this.metrics.suspiciousActivities++;

      if (this.metrics.suspiciousActivities >= this.thresholds.suspiciousActivity) {
        this.createAlert({
          type: '权限提升',
          severity: '关键',
          userId: event.userId,
          permission: event.permission
        });
      }
    }
  }

  checkAlerts(event) {
    // 检查基于严重性的警报
    if (event.severity === '关键') {
      this.createAlert({
        type: '关键事件',
        event: event
      });
    }

    // 检查基于阈值的警报
    if (this.metrics.securityViolations >= this.thresholds.violations) {
      this.createAlert({
        type: '高违规',
        count: this.metrics.securityViolations
      });
    }
  }

  createAlert(alert) {
    const enrichedAlert = {
      ...alert,
      id: `alert_${Date.now()}`,
      timestamp: Date.now(),
      acknowledged: false
    };

    this.alerts.push(enrichedAlert);

    // 发送通知
    this.notifyAlert(enrichedAlert);
  }

  notifyAlert(alert) {
    // 将发送到监控服务
    console.error('安全警报:', alert);

    // 还可以：
    // - 发送电子邮件
    // - 发布到Slack
    // - 触发PagerDuty
    // - 记录到SIEM
  }

  rotateLogs() {
    // 存档旧事件
    const toArchive = this.events.splice(0, 5000);

    // 将写入永久存储
    console.log(`存档 ${toArchive.length} 个安全事件`);
  }

  getReport(timeRange = 3600000) {
    const now = Date.now();
    const recentEvents = this.events.filter(e =>
      e.timestamp > now - timeRange
    );

    const report = {
      timeRange,
      totalEvents: recentEvents.length,
      byType: {},
      bySeverity: {},
      topUsers: {},
      topIPs: {}
    };

    // 按类型聚合
    for (const event of recentEvents) {
      report.byType[event.type] = (report.byType[event.type] || 0) + 1;
      report.bySeverity[event.severity] = (report.bySeverity[event.severity] || 0) + 1;

      if (event.userId) {
        report.topUsers[event.userId] = (report.topUsers[event.userId] || 0) + 1;
      }

      if (event.ip) {
        report.topIPs[event.ip] = (report.topIPs[event.ip] || 0) + 1;
      }
    }

    // 排序顶级用户和IP
    report.topUsers = Object.entries(report.topUsers)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    report.topIPs = Object.entries(report.topIPs)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    return report;
  }
}
```

## 漏洞扫描

### 漏洞扫描器

```javascript
class VulnerabilityScanner {
  constructor() {
    this.scanners = new Map();
    this.vulnerabilities = [];

    this.initializeScanners();
  }

  initializeScanners() {
    // 依赖扫描器
    this.registerScanner('dependencies', {
      async scan() {
        const { execSync } = require('child_process');

        try {
          const result = execSync('npm audit --json', {
            encoding: 'utf8'
          });

          const audit = JSON.parse(result);

          return {
            type: 'dependencies',
            vulnerabilities: audit.vulnerabilities || {},
            severity: audit.metadata?.vulnerabilities || {}
          };

        } catch (error) {
          return {
            type: 'dependencies',
            error: error.message
          };
        }
      }
    });

    // 配置扫描器
    this.registerScanner('configuration', {
      scan() {
        const issues = [];

        // 检查默认凭据
        if (process.env.DEFAULT_PASSWORD) {
          issues.push({
            severity: '关键',
            issue: '检测到默认密码'
          });
        }

        // 检查调试模式
        if (process.env.DEBUG === 'true') {
          issues.push({
            severity: '中等',
            issue: '生产环境中启用了调试模式'
          });
        }

        // 检查TLS配置
        if (!process.env.TLS_CERT) {
          issues.push({
            severity: '高',
            issue: 'TLS未配置'
          });
        }

        return {
          type: 'configuration',
          issues
        };
      }
    });

    // 权限扫描器
    this.registerScanner('permissions', {
      async scan() {
        const fs = await import('fs/promises');
        const issues = [];

        // 检查文件权限
        const sensitiveFiles = [
          '.env',
          'config.json',
          'keys.json'
        ];

        for (const file of sensitiveFiles) {
          try {
            const stats = await fs.stat(file);
            const mode = (stats.mode & parseInt('777', 8)).toString(8);

            if (mode !== '600') {
              issues.push({
                severity: '高',
                issue: `${file}上的不安全权限: ${mode}`
              });
            }
          } catch {
            // 文件不存在
          }
        }

        return {
          type: 'permissions',
          issues
        };
      }
    });

    // 代码扫描器
    this.registerScanner('code', {
      async scan() {
        const issues = [];
        const patterns = [
          { pattern: /eval\(/g, issue: '使用eval()' },
          { pattern: /Function\(/g, issue: '使用Function构造函数' },
          { pattern: /innerHTML/g, issue: '使用innerHTML' },
          { pattern: /document\.write/g, issue: '使用document.write' },
          { pattern: /\.exec\(/g, issue: '直接命令执行' }
        ];

        // 将扫描实际代码文件
        // 为了演示，检查常见模式

        return {
          type: 'code',
          issues
        };
      }
    });
  }

  registerScanner(name, scanner) {
    this.scanners.set(name, scanner);
  }

  async runScan(scanType = null) {
    const results = [];

    const scannersToRun = scanType
      ? [this.scanners.get(scanType)]
      : Array.from(this.scanners.values());

    for (const scanner of scannersToRun) {
      if (scanner) {
        const result = await scanner.scan();
        results.push(result);

        // 存储漏洞
        if (result.vulnerabilities || result.issues) {
          this.storeVulnerabilities(result);
        }
      }
    }

    return this.generateReport(results);
  }

  storeVulnerabilities(scanResult) {
    const timestamp = Date.now();

    if (scanResult.vulnerabilities) {
      for (const [name, vuln] of Object.entries(scanResult.vulnerabilities)) {
        this.vulnerabilities.push({
          type: scanResult.type,
          name,
          severity: vuln.severity,
          timestamp
        });
      }
    }

    if (scanResult.issues) {
      for (const issue of scanResult.issues) {
        this.vulnerabilities.push({
          type: scanResult.type,
          ...issue,
          timestamp
        });
      }
    }
  }

  generateReport(scanResults) {
    const report = {
      timestamp: Date.now(),
      scans: scanResults.length,
      totalVulnerabilities: 0,
      bySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      recommendations: []
    };

    // 聚合漏洞
    for (const result of scanResults) {
      if (result.vulnerabilities) {
        const vulns = Object.values(result.vulnerabilities);
        report.totalVulnerabilities += vulns.length;

        for (const vuln of vulns) {
          report.bySeverity[vuln.severity]++;
        }
      }

      if (result.issues) {
        report.totalVulnerabilities += result.issues.length;

        for (const issue of result.issues) {
          report.bySeverity[issue.severity]++;
        }
      }
    }

    // 生成建议
    if (report.bySeverity.critical > 0) {
      report.recommendations.push('立即解决关键漏洞');
    }

    if (report.bySeverity.high > 5) {
      report.recommendations.push('检测到大量高严重性问题');
    }

    return report;
  }

  async autoFix(vulnerability) {
    // 尝试自动修复
    switch (vulnerability.type) {
      case 'dependencies':
        // 运行npm audit fix
        const { execSync } = require('child_process');
        try {
          execSync('npm audit fix');
          return { fixed: true };
        } catch (error) {
          return { fixed: false, error: error.message };
        }

      case 'permissions':
        // 修复文件权限
        const fs = await import('fs/promises');
        try {
          await fs.chmod(vulnerability.file, '600');
          return { fixed: true };
        } catch (error) {
          return { fixed: false, error: error.message };
        }

      default:
        return { fixed: false, error: '无可用的自动修复' };
    }
  }
}
```

## 性能影响

### 安全性能分析

```javascript
class SecurityPerformanceAnalyzer {
  static async analyzePerformance() {
    const metrics = {
      validationOverhead: await this.measureValidation(),
      injectionPreventionCost: await this.measureInjectionPrevention(),
      pathSecurityOverhead: await this.measurePathSecurity(),
      rateLimitingCost: await this.measureRateLimiting(),
      monitoringOverhead: await this.measureMonitoring()
    };

    return this.generateAnalysis(metrics);
  }

  static async measureValidation() {
    const validator = new InputValidationFramework();
    const testInput = 'echo "测试命令"';

    const iterations = 10000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      await validator.validate(testInput, 'command');
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measureInjectionPrevention() {
    const sqlPrevention = new SQLInjectionPrevention();
    const testQuery = 'SELECT * FROM users WHERE id = ?';
    const testParams = ['123'];

    const iterations = 10000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      sqlPrevention.prevent(testQuery, testParams);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measurePathSecurity() {
    const pathManager = new PathSecurityManager();
    const testPath = '/tmp/test/file.txt';

    const iterations = 10000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      pathManager.validatePath(testPath);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measureRateLimiting() {
    const rateLimiter = new RateLimiter();
    rateLimiter.configureLimits();

    const testIdentifier = 'test-user';

    const iterations = 1000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      await rateLimiter.checkLimit(testIdentifier);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static async measureMonitoring() {
    const monitor = new SecurityMonitor();
    const testEvent = {
      type: 'auth.attempt',
      userId: 'test-user',
      ip: '192.168.1.1'
    };

    const iterations = 1000;
    const start = process.hrtime.bigint();

    for (let i = 0; i < iterations; i++) {
      monitor.logEvent(testEvent);
    }

    const end = process.hrtime.bigint();
    return Number(end - start) / 1e6 / iterations;
  }

  static generateAnalysis(metrics) {
    const analysis = {
      metrics,
      totalOverhead: Object.values(metrics).reduce((sum, val) => sum + val, 0),
      recommendations: [],
      performanceGrade: 'A'
    };

    // 生成建议
    if (metrics.validationOverhead > 0.5) {
      analysis.recommendations.push('考虑缓存验证结果');
    }

    if (metrics.injectionPreventionCost > 0.3) {
      analysis.recommendations.push('使用预处理语句以获得更好的性能');
    }

    if (metrics.pathSecurityOverhead > 0.2) {
      analysis.recommendations.push('实施路径验证缓存');
    }

    if (metrics.rateLimitingCost > 0.5) {
      analysis.recommendations.push('使用Redis进行分布式速率限制');
    }

    if (metrics.monitoringOverhead > 1.0) {
      analysis.recommendations.push('考虑异步日志记录进行监控');
    }

    // 计算性能等级
    if (analysis.totalOverhead > 5) {
      analysis.performanceGrade = 'C';
    } else if (analysis.totalOverhead > 2) {
      analysis.performanceGrade = 'B';
    }

    return analysis;
  }
}
```

## 总结

Claude Code的漏洞预防系统提供：

1. **全面的输入验证**：具有类型特定规则的多层验证
2. **注入攻击预防**：SQL、NoSQL和命令注入保护
3. **路径安全**：基于监狱的路径限制与遍历预防
4. **安全命令执行**：具有资源限制的白名单命令
5. **速率限制**：具有滥用检测的令牌桶算法
6. **DoS预防**：资源监控和攻击模式检测
7. **安全监控**：实时威胁检测和警报
8. **漏洞扫描**：自动安全评估和修复

该系统在保持性能和可用性的同时主动预防常见漏洞。

## 下一步

这完成了第10部分：安全。下一部分将探讨Claude Code系统的可扩展性功能。

---

*Claude Code技术系列的一部分 - 安全*